{"ast":null,"code":"import { createFeatureSelector, createSelector } from '@ngrx/store';\nexport const authFeatureSelector = createFeatureSelector('auth'); //creating a type for create feature selector method. this removes Type T or generic type. in doing so, this\n//tells which interface we are using for the global state property and which interface we are using to pass into that global state.\n//e.g appstate is gbl state and authstate is the interface within. this creates a memoized selector.\n//feature selector allows us to access the state properties in 'auth' --> which we then create a selector for below to return the value\n//of property isSubmitting. 'auth' is defined as a property in appStateInterface. but the state is defined intially in auth.module. as 'auth'.\n//FLOW ==> AppStateInterface has PROP 'auth' OF TYPE AuthStateInterface ==> createFeatureSelector() takes state 'auth' when passed as a\n// parameter from auth.module.ts ==>createSelector() TAKES 2 ARGS -> created_feature_selector_var & LAMBDA FUNC. RETURN PROP IN 'auth'\n//e.g isSubmitting is PROP in authStateInterface. we can then use it in component as observable object. don't forget to use async pipe!\n\nexport const isSubmittingSelector = createSelector(authFeatureSelector, authState => authState.isSubmitting); //the above selector can be seen as a getter, the getter is for a property, isSubmitting. the above code can be reused for other prop getters asd well\n//type of authstateinteface is implicitly written for other devs to understand the code space better. also, referencing implicitly can be seen when wanting\n//to inspect the areas where that interface is used in other code areas.\n\nexport const validationErrorsSelector = createSelector(authFeatureSelector, authState => authState.validationErrors);\nexport const isLoggedInSelector = createSelector(authFeatureSelector, authState => authState.isLoggedIn);","map":{"version":3,"sources":["C:/Users/river/source/repos/Angular/BuySellBot/buy-sell-bot/src/app/store/selectors.ts"],"names":["createFeatureSelector","createSelector","authFeatureSelector","isSubmittingSelector","authState","isSubmitting","validationErrorsSelector","validationErrors","isLoggedInSelector","isLoggedIn"],"mappings":"AAAA,SAASA,qBAAT,EAAgCC,cAAhC,QAAsD,aAAtD;AACA,OAAO,MAAMC,mBAAmB,GAAGF,qBAAqB,CAAC,MAAD,CAAjD,C,CACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMG,oBAAoB,GAAGF,cAAc,CAACC,mBAAD,EAAuBE,SAAD,IAAeA,SAAS,CAACC,YAA/C,CAA3C,C,CACP;AACA;AACA;;AACA,OAAO,MAAMC,wBAAwB,GAAGL,cAAc,CAACC,mBAAD,EAAuBE,SAAD,IAAeA,SAAS,CAACG,gBAA/C,CAA/C;AACP,OAAO,MAAMC,kBAAkB,GAAGP,cAAc,CAACC,mBAAD,EAAuBE,SAAD,IAAeA,SAAS,CAACK,UAA/C,CAAzC","sourcesContent":["import { createFeatureSelector, createSelector } from '@ngrx/store';\r\nexport const authFeatureSelector = createFeatureSelector('auth');\r\n//creating a type for create feature selector method. this removes Type T or generic type. in doing so, this\r\n//tells which interface we are using for the global state property and which interface we are using to pass into that global state.\r\n//e.g appstate is gbl state and authstate is the interface within. this creates a memoized selector.\r\n//feature selector allows us to access the state properties in 'auth' --> which we then create a selector for below to return the value\r\n//of property isSubmitting. 'auth' is defined as a property in appStateInterface. but the state is defined intially in auth.module. as 'auth'.\r\n//FLOW ==> AppStateInterface has PROP 'auth' OF TYPE AuthStateInterface ==> createFeatureSelector() takes state 'auth' when passed as a\r\n// parameter from auth.module.ts ==>createSelector() TAKES 2 ARGS -> created_feature_selector_var & LAMBDA FUNC. RETURN PROP IN 'auth'\r\n//e.g isSubmitting is PROP in authStateInterface. we can then use it in component as observable object. don't forget to use async pipe!\r\nexport const isSubmittingSelector = createSelector(authFeatureSelector, (authState) => authState.isSubmitting);\r\n//the above selector can be seen as a getter, the getter is for a property, isSubmitting. the above code can be reused for other prop getters asd well\r\n//type of authstateinteface is implicitly written for other devs to understand the code space better. also, referencing implicitly can be seen when wanting\r\n//to inspect the areas where that interface is used in other code areas.\r\nexport const validationErrorsSelector = createSelector(authFeatureSelector, (authState) => authState.validationErrors);\r\nexport const isLoggedInSelector = createSelector(authFeatureSelector, (authState) => authState.isLoggedIn);\r\n"]},"metadata":{},"sourceType":"module"}